좋아, 핵심만 딱 정리해줄게.

# u, v가 뭐냐?

* 한 눈(왼쪽/오른쪽)에 대해,

  * **눈 중앙** $c$: 눈둘레(눈꺼풀 경계) 랜드마크들의 평균.
  * **홍채 중심** $p$: 홍채(iris) 포인트들의 평균.
  * **주성분 축** $\hat u, \hat v$: 눈둘레 점들에 PCA를 돌려 얻은 두 축.

    * $\hat u$: 보통 **눈 길이 방향(가로)** 축.
    * $\hat v$: 보통 **눈 높이 방향(세로)** 축.
  * **스케일** $s_u, s_v$: 각각의 축으로 본 눈의 “반쪽 길이” (프레임마다 추정).

* 그러면 프레임 $t$에서의 눈동자 상대 위치는

  $$
  u = \frac{(p - c)\cdot \hat u}{s_u},\quad
  v = \frac{(p - c)\cdot \hat v}{s_v}.
  $$

  즉, **눈 모양으로 정규화된 홍채 중심의 가로/세로 편차**(단위 없음).

* 코드에선 눈마다 따로 계산하니 **uL,vL / uR,vR**가 생겨.
  (미러 프리뷰를 켰으면 영상이 좌우 반전된 기준에서 계산되지만, 캘리브레이션으로 결국 화면 좌표로 보정돼.)

# u–v 산점도 한 점이 의미하는 것

* **그 프레임에서** “홍채 중심이 눈 중앙에서 어느 방향으로, 눈 크기에 비해 얼마나 움직였나”를 나타내는 **정규화 좌표** 한 점.
* 대략 $[-1,1]$ 안에 주로 모이지만, 눈을 크게 굴리거나 검출 오류가 나면 벗어날 수 있어.

# pt\_index별 u–v 산점도에서 읽는 법

(각 pt\_index는 특정 화면 위치를 응시할 때 모은 샘플 묶음)

1. **클러스터 중심(평균)**

   * (0,0)에서 벗어나면 그 위치에서 **체계적 편향**이 있음을 시사(축/스케일 추정, 카메라–화면 정렬 영향).

2. **퍼짐(분산, 표준편차)** = **정밀도**

   * 작을수록 좋다(응시가 안정적, 피처 노이즈 적음).
   * 한쪽으로 길게 늘어지면 그 축(가로/세로)에서 **민감도/노이즈 불균형**.

3. **기울기(상관)**

   * 타원이 기울어 있으면 $u$와 $v$가 **상관**됨 = 축 추정이 살짝 비틀렸거나 프레임 간 축 변동이 남아 있음.

4. **좌/우 눈 비교(파란=왼쪽, 빨간=오른쪽 등으로 그렸을 때)**

   * 두 분포가 비슷하면 **양안 일관성** OK.
   * 한쪽이 더 넓거나 평균이 치우치면 **한쪽 눈 검출 품질/조명/가림** 문제 가능.

5. **이상치**

   * 군집에서 멀리 떨어진 점(깜박임, 잠깐의 추적 실패).
   * 비율이 높으면 클리닝/스무딩 파라미터 점검.

# 전형적 패턴 → 해석

* **세로 폭이 유난히 좁음**: v(상하) 감도 부족. → v-gain, eyelid 기반 추가 피처, 축 안정화/스무딩 보강.
* **모서리 pt에서 퍼짐↑**: 비선형성/외삽 영향. → 그리드 촘촘히, 비선형 모델(MLP) 학습.
* **좌우 평균 차 큼**: 한쪽 눈 추정 품질 차이. → 조명 균등화, 눈둘레 포인트 확장/정제.

# 왜 u,v를 쓰나?

* **머리 미세움직임/줌 변화**를 눈 자체의 크기/축으로 **정규화**해서, “눈동자 상대 움직임”만 뽑으려는 목적.
* 이 \*\*정규화 피처(u,v)\*\*들을 회귀/MLP에 넣어 \*\*화면 좌표 $(x,y)$\*\*를 예측한다(캘리브레이션이 그 매핑을 학습).

원하면, 네 산점도에서 **각 pt\_index의 평균·공분산·이상치율**을 자동으로 계산해 표로 뽑아주는 스크립트도 바로 만들어줄게.













