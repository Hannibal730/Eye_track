좋아! 지금 12차원 특징 벡터는 **양쪽 눈의 홍채(iris) 중심이 ‘눈 자체의 좌표계’에서 어디에 있는지**를 담고, 그걸 **2차 다항(제곱·곱)** 으로 확장한 값들이야. 프레임마다 한 번씩 계산돼.

# 계산 파이프라인(요약)

1. **MediaPipe Face Mesh**로 얼굴 랜드마크를 얻음(정규화 좌표 x,y).
2. 각 눈에 대해 **눈 윤곽 포인트 집합**(FACEMESH\_LEFT\_EYE/RIGHT\_EYE) → 픽셀 좌표로 변환.
3. 그 점들로 **PCA**를 해서 눈의 2축(가로축 `ax1`, 세로축 `ax2`)과 중심 `c`를 구함.

   * 이 축은 매 프레임 눈의 **회전/스케일/기울어짐**을 흡수하는, 눈 고유 좌표계라고 보면 됨.
4. **홍채 중심**(`ic`)을 (iris 네 점 평균)으로 구함.
5. `ic`가 눈 중심 `c`에서 얼마나 이동했는지, 축 방향으로 **정규화 오프셋**을 구함:

   * `u = dot(ic − c, ax1) / (w/2)`  (가로)
   * `v = dot(ic − c, ax2) / (h/2)`  (세로)
     여기서 `w, h`는 PCA 축 기준 **RMS 폭**(프레임마다 갱신)으로 스케일 맞춤.

이렇게 해서 왼눈의 `(uL, vL)`, 오른눈의 `(uR, vR)`를 얻고, 아래처럼 2차 확장을 만들어 12차원으로 묶어.

# 12차원 각 항목이 뭔지

1. **`uL`**: 왼눈 홍채 중심의 **가로 방향** 정규화 오프셋

   * 기준: 왼눈 중심 `c_L`, 가로축 `ax1_L`, 스케일 `w_L/2`

2. **`vL`**: 왼눈 홍채 중심의 **세로 방향** 정규화 오프셋

   * 기준: 왼눈 중심 `c_L`, 세로축 `ax2_L`, 스케일 `h_L/2`

3. **`uR`**: 오른눈 **가로 오프셋**

4. **`vR`**: 오른눈 **세로 오프셋**

5. **`uL2`**: `uL²` (왼눈 가로 오프셋 제곱)

6. **`vL2`**: `vL²` (왼눈 세로 오프셋 제곱)

7. **`uR2`**: `uR²`

8. **`vR2`**: `vR²`

9. **`uL_vL`**: `uL·vL` (왼눈 가로·세로 상호작용)

10. **`uR_vR`**: `uR·vR` (오른눈 상호작용)

11. **`uL_uR`**: `uL·uR` (양눈 가로 상호작용: **vergence/시차** 같은 효과 일부 포착)

12. **`vL_vR`**: `vL·vR` (양눈 세로 상호작용)

> 요지는: **u,v 네 개의 1차 항** + **제곱 4개** + **상호작용 4개** = 12D.
> 이걸로 **2차 다항 회귀(릿지)** 를 해서 화면 픽셀 (x,y)을 바로 예측해.

# 왜 이런 모양으로 정규화하나?

* **눈 좌표계(PCA 축)** 를 쓰면, 고개가 약간 돌아가거나 눈꺼풀 모양이 바뀌어도 **상대 위치**로 잡히므로 **회전/스케일에 덜 민감**해져.
* `w/2`, `h/2`로 나눠서 **무단위화(대개 −1\~+1 근처)** → 사람/프레임마다 눈 크기 차이를 완화.
* 2차 항과 상호작용 항은 실제 스크린 매핑의 **비선형성**(눈 기하·렌즈 효과·개인 편차)을 보정하는 역할.

# 코드 상에서 어디서 계산되나?

* **눈 좌표계 추출**: `_pca_axes()` — 눈 윤곽점을 PCA로 중심 `c`, 축 `ax1/ax2`, 폭 `w/h` 계산
* **홍채 중심**: `_iris_center()` — iris 네 점 평균
* **정규화 오프셋**: `_eye_uv()` — 위 공식을 그대로 적용해 `(u, v)` 반환
* **특징 벡터 구성**: `_feat_vector()` — 12D로 묶어서 반환

# 값의 범위/해석

* `u, v`는 보통 **−1 \~ +1** 근처(사람·프레임에 따라 ±1.5까지 갈 수 있음).
* 프레임마다 PCA 축의 **부호는 수학적으로 뒤집힐 수도** 있으나(고유벡터 부호 불변성), 실제로는 초 단위 프레임에서 눈 윤곽이 크게 변하지 않아 **거의 안정적**이야. 그래도 혹시 드문 **축 부호 플립**이 신경 쓰이면:

  * 눈꼬리-안쪽꼬리(외안각↔내안각) 벡터 방향으로 **가로축 고정**하거나,
  * 이전 프레임 축과의 내적이 음수면 **축 부호를 통일**하는 소정의 코드 한 줄을 넣어줄 수 있어.

----



다음은 CSV 1행(헤더)의 각 컬럼 의미야. 

### 입력 특징(12D)

* `uL, vL`: **왼쪽 눈 홍채 중심**을 왼눈의 **PCA 두 축(가로/세로)** 에 사영한 정규화 좌표.
  눈둘레 랜드마크의 중심과 분산으로 축·스케일을 구한 뒤, 홍채 중심을 그 축에 투영해서 **눈 박스 반경(w/2, h/2)로 나눈 값**이라 대략 -1\~+1 범위가 됨.
* `uR, vR`: 오른쪽 눈에 대해 동일.
* `uL2, vL2, uR2, vR2`: 위 네 값의 **제곱 항**. (비선형성 보강)
* `uL_vL, uR_vR`: **같은 눈 내부**의 가로·세로 상호작용 항(곱).
* `uL_uR, vL_vR`: **양눈 간** 상호작용 항(곱).
  → 이 12D는 2차 다항 기저로 확장한 특징으로, 가벼운 **릿지 회귀**만으로도 화면 좌표의 비선형 관계를 근사하기 쉽게 해 둔 것.&#x20;

### 타깃(라벨)

* `Y_x, Y_y`: 수집 시점에 사용자가 응시하도록 제시된 **화면 타깃의 픽셀 좌표**(왼쪽 위가 원점).
  캘리브레이션 그리드에서 현재 포인트의 정규화 좌표를 화면 해상도로 바꾼 값이며, 모델이 예측하도록 학습하는 **정답 좌표**가 여기에 들어간다.&#x20;

### 메타

* `T`: 샘플 타임스탬프(초, `float64`). 프레임 간 간격·유효 FPS 계산 등에 사용.&#x20;
* `pt_index`: 해당 샘플이 **그리드의 몇 번째 점**에서 수집됐는지 나타내는 정수(수집 순서: 행 지그재그).&#x20;
* `screen_w, screen_h`: 수집 당시 **화면 해상도**(픽셀). 모델/시각화 시 좌표계 일치용.&#x20;

---

## 왜 `Y_x`, `Y_y`로 저장했나?

* 데이터 구조에서 **`X`는 이미 “입력 특징 행렬”**(N×12) 이름으로 쓰이고, **`Y`는 2차원 벡터**라 CSV 한 칸에 넣을 수 없어.
* 그래서 **컬럼 두 개**로 나눠 `Y_x`, `Y_y`로 명시하면,

  * CSV/판다스/대부분의 ML 파이프라인에서 바로 쓰기 편하고,
  * “입력 X와 출력 Y의 x/y 성분”이 무엇인지 **이름만으로 명확**해져.

원한다면 변환 스크립트에서 컬럼명을 `x, y`로 바꾸거나(동일 의미), `Y` 한 칼럼에 `"x,y"` 문자열로 묶어 쓰게 바꿀 수도 있어. 하지만 후자는 학습 전에 다시 파싱해야 해서 보통은 `Y_x, Y_y`처럼 **성분 분리**가 가장 깔끔해.




