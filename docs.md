좋아! 지금 12차원 특징 벡터는 **양쪽 눈의 홍채(iris) 중심이 ‘눈 자체의 좌표계’에서 어디에 있는지**를 담고, 그걸 **2차 다항(제곱·곱)** 으로 확장한 값들이야. 프레임마다 한 번씩 계산돼.

# 계산 파이프라인(요약)

1. **MediaPipe Face Mesh**로 얼굴 랜드마크를 얻음(정규화 좌표 x,y).
2. 각 눈에 대해 **눈 윤곽 포인트 집합**(FACEMESH\_LEFT\_EYE/RIGHT\_EYE) → 픽셀 좌표로 변환.
3. 그 점들로 **PCA**를 해서 눈의 2축(가로축 `ax1`, 세로축 `ax2`)과 중심 `c`를 구함.

   * 이 축은 매 프레임 눈의 **회전/스케일/기울어짐**을 흡수하는, 눈 고유 좌표계라고 보면 됨.
4. **홍채 중심**(`ic`)을 (iris 네 점 평균)으로 구함.
5. `ic`가 눈 중심 `c`에서 얼마나 이동했는지, 축 방향으로 **정규화 오프셋**을 구함:

   * `u = dot(ic − c, ax1) / (w/2)`  (가로)
   * `v = dot(ic − c, ax2) / (h/2)`  (세로)
     여기서 `w, h`는 PCA 축 기준 **RMS 폭**(프레임마다 갱신)으로 스케일 맞춤.

이렇게 해서 왼눈의 `(uL, vL)`, 오른눈의 `(uR, vR)`를 얻고, 아래처럼 2차 확장을 만들어 12차원으로 묶어.

# 12차원 각 항목이 뭔지

1. **`uL`**: 왼눈 홍채 중심의 **가로 방향** 정규화 오프셋

   * 기준: 왼눈 중심 `c_L`, 가로축 `ax1_L`, 스케일 `w_L/2`

2. **`vL`**: 왼눈 홍채 중심의 **세로 방향** 정규화 오프셋

   * 기준: 왼눈 중심 `c_L`, 세로축 `ax2_L`, 스케일 `h_L/2`

3. **`uR`**: 오른눈 **가로 오프셋**

4. **`vR`**: 오른눈 **세로 오프셋**

5. **`uL2`**: `uL²` (왼눈 가로 오프셋 제곱)

6. **`vL2`**: `vL²` (왼눈 세로 오프셋 제곱)

7. **`uR2`**: `uR²`

8. **`vR2`**: `vR²`

9. **`uL_vL`**: `uL·vL` (왼눈 가로·세로 상호작용)

10. **`uR_vR`**: `uR·vR` (오른눈 상호작용)

11. **`uL_uR`**: `uL·uR` (양눈 가로 상호작용: **vergence/시차** 같은 효과 일부 포착)

12. **`vL_vR`**: `vL·vR` (양눈 세로 상호작용)

> 요지는: **u,v 네 개의 1차 항** + **제곱 4개** + **상호작용 4개** = 12D.
> 이걸로 **2차 다항 회귀(릿지)** 를 해서 화면 픽셀 (x,y)을 바로 예측해.

# 왜 이런 모양으로 정규화하나?

* **눈 좌표계(PCA 축)** 를 쓰면, 고개가 약간 돌아가거나 눈꺼풀 모양이 바뀌어도 **상대 위치**로 잡히므로 **회전/스케일에 덜 민감**해져.
* `w/2`, `h/2`로 나눠서 **무단위화(대개 −1\~+1 근처)** → 사람/프레임마다 눈 크기 차이를 완화.
* 2차 항과 상호작용 항은 실제 스크린 매핑의 **비선형성**(눈 기하·렌즈 효과·개인 편차)을 보정하는 역할.

# 코드 상에서 어디서 계산되나?

* **눈 좌표계 추출**: `_pca_axes()` — 눈 윤곽점을 PCA로 중심 `c`, 축 `ax1/ax2`, 폭 `w/h` 계산
* **홍채 중심**: `_iris_center()` — iris 네 점 평균
* **정규화 오프셋**: `_eye_uv()` — 위 공식을 그대로 적용해 `(u, v)` 반환
* **특징 벡터 구성**: `_feat_vector()` — 12D로 묶어서 반환

# 값의 범위/해석

* `u, v`는 보통 **−1 \~ +1** 근처(사람·프레임에 따라 ±1.5까지 갈 수 있음).
* 프레임마다 PCA 축의 **부호는 수학적으로 뒤집힐 수도** 있으나(고유벡터 부호 불변성), 실제로는 초 단위 프레임에서 눈 윤곽이 크게 변하지 않아 **거의 안정적**이야. 그래도 혹시 드문 **축 부호 플립**이 신경 쓰이면:

  * 눈꼬리-안쪽꼬리(외안각↔내안각) 벡터 방향으로 **가로축 고정**하거나,
  * 이전 프레임 축과의 내적이 음수면 **축 부호를 통일**하는 소정의 코드 한 줄을 넣어줄 수 있어.

# 확장 팁(원하면 추가 가능)

* **머리 포즈(roll/pitch/yaw)**, **양눈 거리/iris 반경**, **깜빡임 신뢰도** 등을 특징에 추가 → 더 튼튼한 매핑
* 12D 대신 **작은 MLP**(예: 32–64 유닛 2층)로 비선형 매핑 → 정밀도 상승
* 캘리브 중 **워밍업 구간 제외/깜빡임 프레임 제거/가중 회귀**로 라벨 품질 개선

필요하면 위 “축 부호 고정”이나 “머리 포즈 추가” 코드를 바로 끼워 넣어서 보내줄게.
